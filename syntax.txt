OVERVIEW OF CSASM
=================

CSASM is a stack-based language written in an assembly-like syntax that is executed like a C# program.


All CSASM files should have the extension ".csa".

For any given CSASM project, a function named "main" must be defined.  This is where the code will start running from in the CSASM sandbox.

The stack is internally represented as a Stack<dynamic>, meaning any values can be pushed to it.
Care should be used when popping entries from the stack since attempting to pop an entry from the stack with an invalid type will cause a runtime error.

For the sake of consistency with assembly in general, all defined functions are static.
Functions can be marked as "private" or "public".  Private functions are only visible from within a given file, whereas public functions are visible everywhere.


DEFINED TOKENS
==============

.asm_name ............... The name of the assembly.  Defaults to "csasm_prog" if not defined.

.global ................. Marks a token as a global variable

.hide ................... Marks a function as "private".  Methods default to "public" if this token isn't used

.include <path> ......... Inserts the contents of the file located at <path> into the current file during the compilation process.
                          If <path> is surrounded by <> (e.g. ".include <header>"), the file is expected to be found in the "Headers" folder where the compiler executable is located.

.lbl <name> ............. Defines a jump/branch label whose name is <name>.  Labels must be contained in methods and are bound to the scope of the method
.local .................. Marks atoken as a local variable

.pub .................... Marks a function as "public".

.stack .................. The capacity of the stack this assembly will use.  Defaults to 1000 entries.

#define <name> [body] ... Defines a macro with the given <name> and an optional one-liner [body].

#endif .................. Paired with #ifdef or #ifndef.  Ends a preprocessor conditional

#ifdef <macro> .......... Paired with #endif.  Starts the beginning of a preprocessor conditional.  If <macro> exists, the conditional body is included during the compilation process.
#ifndef <macro> ......... Paired with #endif.  Starts the beginning of a preprocessor conditional.  If <macro> does not exist, the conditional body is included during the compilation process.

#undef <name> ........... Removes a macro definition, if it exists

end ..................... Ends a method declaration

func <name>: ............ Begins a method declaration whose name is <name>


DEFINED TYPES
=============

~arr:<type>,<i32> ....... A new <type> array instance with <i32> elements

^<i32> .................. An indexing type used for the "ldelem" and "stelem" instructions.  See docs.txt to see how it's used.

char .................... Character literal type

f32 ..................... 32-bit floating-point type
f64 ..................... 64-bit floating-point type

i16 ..................... Signed 16-bit integer type
i32 ..................... Signed 32-bit integer type
i64 ..................... Signed 64-bit integer type
i8 ...................... Signed 8-bit integer type

obj ..................... Object type

str ..................... String type

u16 ..................... Unsigned 16-bit integer type
u32 ..................... Unsigned 32-bit integer type
u64 ..................... Unsigned 64-bit integer type
u8 ...................... Unsigned 8-bit integer type


DEFINED INSTRUCTIONS
====================
When popping elements from the stack, "A" will refer to the topmost element and "B" will refer to the element after that

abs ..................... Pops A, then pushes its absolute value
add ..................... Pops A and B, then pushes A + B.  If either A or B is a <str>, string concatenation is performed instead, then the result is pushed to the stack.
asl ..................... Pops A (an integer), then pushes A << 1
asr ..................... Pops A (an integer), then pushes A >> 1

bytes ................... Pops A, then pushes how many bytes of memory A uses.
br <label> .............. Unconditionally jumps execution to <label>
brfalse <label> ......... Jumps execution to <label> iff the accumulator contains a null, zero or an empty string
brtrue <label> .......... Jumps execution to <label> iff the accumulator contains a non-zero value or a non-empty string

call <func> ............. Calls a function.  The function's arguments must be pushed to the stack before this instruction
clf.c ................... Clears the Carry flag
clf.o ................... Clears the Comparison flag
cls ..................... Clears the console
comp .................... Pops A and B, then sets the Comparison flag iff A == B
comp.gt ................. Pops A and B, then sets the Comparison flag iff B > A
comp.gte ................ Pops A and B, then sets the Comparison flag iff B >= A
comp.lt ................. Pops A and B, then sets the Comparison flag iff B < A
comp.lte ................ Pops A and B, then sets the Comparison flag iff B <= A
conrc ................... Reverts the console's colours to its defaults
conv <type> ............. Pops A, converts it to <type>, then pushes the result
conv.a <type> ........... Converts the value in the accumulator to the given type

dec <var> ............... Decrements an integer stored in <var> by one
div ..................... Pops A and B, then pushes B / A.  If B is a <str> and A is a <str> or <char>, the result of "B.Split(A)" (an <~arr:str>) is pushed to the stack instead.
dup ..................... Pops A, then pushes A twice

exit .................... Stops the program

in <str> ................ Prints <str>, then waits for a newline-terminated string of text.  The input is pushed to the stack
inc <var> ............... Increments an integer stored in <var> by one
ink <str> ............... Prints <str>, then waits for the user to press a key.  The <char> key input is pushed to the stack
inki <str> .............. Prints <str>, then waits for the user to press a key (the key will not appear in the command prompt).  The <char> key is pushed to the stack
interp <str> ............ Pops A (an <obj> array), then uses its values to modify <str>
is <type> ............... Pops A, then sets the Comparison flag iff A has the same type as <type>
is.a <type> ............. Sets the Comparison flag iff the value contained in the accumulator has the same type as <type>
isarr <type> ............ Pops A, then sets the Comparison flag iff A is an array and its element type is <type>.  For checking if A is just an array, pass in obj as the <type>

lda <var> ............... Stores <var> into the accumulator
ldelem <index> .......... Pops A (an array instance), then pushes the value contained in A at the zero-based index <index>
len ..................... Pops A (an array instance), then pushes the length of A

mul ..................... Pops A and B, then pushes A * B.  If B is a <str> and A is a positive integer, B will be repeated A times in one <str> and that <str> is pushed to the stack instead.

neg ..................... Pops A, then pushes -A
newarr <type> ........... Pops A (an <i32>), then pushes a new <type> array instance whose length is A
not ..................... Pops A (an integer), then pushes ~A

pop <var> ............... Pops A, then stores it in <var>
popd .................... Pops A
print ................... Pops A, then prints its string representation to the console
print.n ................. Pops A, then prints its string representation to the console with a newline appended
push <arg> .............. Pushes <arg> to the stack

ret ..................... Returns from a method
rol ..................... Pops A (an integer), pushes (A << 1) | Carry, then sets or clears the Carry flag based on the Most Significant Bit of A
ror ..................... Pops A (an integer), pushes (A >> 1) | (Carry << (sizeof(A) * 8 - 1)), then sets or clears the Carry flag based on the Least Significant Bit of A

sta <var> ............... Stores the value in the accumulator in <var>
stelem <index> .......... Pops A (an array instance) and B (the value to store), then stores B in A at the zero-based index <index>
stf.c ................... Sets the Carry flag
stf.o ................... Sets the Comparison flag
sub ..................... Pops A and B, then pushes B - A.  If B is a <str> and A is a <str> or <char>, all instances of A will be removed from B and the result will be pushed to the stack.

throw <str> ............. Throws a "ThrowException" with whose message is <str>
type .................... Pops A, then pushes a <str> representing its type


DEFINED REGISTERS
=================

$a ...................... The accumulator

$1 ...................... A register.  Can be used to store any value independently of the stack
$2 ......................   ---
$3 ......................   ---
$4 ......................   ---
$5 ......................   ---

$con.bcol ............... The current color of the background.  Expected values are between 0 and 15, inclusive.
$con.bh ................. The console's buffer height
$con.bw ................. The console's buffer width
$con.caps ............... Whether the CAPS LOCK key is active
$con.cx ................. The X-position of the cursor in the console buffer
$con.cy ................. The Y-position of the cursor in the console buffer
$con.fcol ............... The current color of the foreground.  Expected values are between 0 and 15, inclusive.
$con.ttl ................ The console's title
$con.wh ................. The console's window height
$con.ww ................. The console's window width

$f.c .................... The Carry flag
$f.o .................... The Comparison flag